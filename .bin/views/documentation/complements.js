var jade = require("jadum/runtime");
module.exports = function complements(locals) {
var jade_debug = [{ lineno: 1, filename: "views/documentation/complements.jade" }];
try {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (undefined) {
jade_debug.unshift({ lineno: 0, filename: "views/documentation/complements.jade" });
jade_debug.unshift({ lineno: 1, filename: "views/documentation/complements.jade" });
buf.push("<section class=\"ly-section md-markdown\">");
jade_debug.unshift({ lineno: undefined, filename: jade_debug[0].filename });
jade_debug.unshift({ lineno: 2, filename: "views/documentation/complements.jade" });
buf.push("<h1 id=\"complementary-modules\">Complementary Modules</h1>\n<p>Taunus is a small library by MVC framework standards, sitting <strong>below 15kB minified and gzipped</strong>. It is designed to be small. It is also designed to do one thing well, and that&#39;s <em>being a shared-rendering MVC engine</em>.</p>\n<p>Taunus can be used for routing, putting together controllers, models and views to handle human interaction. If you <a href=\"/api\">head over to the API documentation</a>, you&#39;ll notice that the server-side API, the command-line interface, and the <code>.taunusrc</code> manifest are only concerned with providing a conventional shared-rendering MVC engine.</p>\n<p>In the server-side you might need to do other things besides routing and rendering views, and other modules can take care of that. However, you&#39;re used to having database access, search, logging, and a variety of services handled by separate libraries, instead of a single behemoth that tries to do everything.</p>\n<blockquote>\n<p>In the client-side, you might be used to your MVC framework of choice resolving everything on your behalf, from DOM manipulation and data-binding to hooking up with a REST API, and everywhere in between.</p>\n</blockquote>\n<p>Taunus attempts to bring the server-side mentality of <em>&quot;not doing everything is okay&quot;</em> into the world of client-side web application development as well. To that end, Taunus recommends that you give a shot to libraries that also do <strong>one thing well</strong>.</p>\n<p>In this brief article we&#39;ll recommend three different libraries that play well with Taunus, and you&#39;ll also learn how to search for modules that can give you access to other functionality you may be interested in.</p>\n<h1 id=\"using-dominus-for-dom-querying\">Using <code>dominus</code> for DOM querying</h1>\n<p><a href=\"https://github.com/bevacqua/dominus\">Dominus</a> is an extra-small DOM querying library, currently clocking around <strong>4kB minified and gzipped</strong>, almost <em>ten times smaller</em> than it&#39;s competition. Unlike jQuery and popular friends, Dominus doesn&#39;t provide AJAX features, layout math, <code>&lt;form&gt;</code> manipulation, promises, tens of event binding methods, a selector engine written in plain JavaScript, nor a myriad of utility functions. Instead, Dominus focuses solely on providing a rich DOM querying and manipulation API that gets rid of inconsistencies across browsers.</p>\n<p>While the API isn&#39;t exactly compatible with jQuery, it is definitely familiar to the jQuery adept. Chaining, versatility, expressiveness, and raw power are all core concerns for Dominus. You&#39;ll find that Dominus has more consistently named methods, given that it was built with a concise API in mind.</p>\n<p>There&#39;s a few differences in semantics, and I believe that&#39;s a good thing. For instance, if you do <code>.value</code> on a checkbox or radio button you&#39;ll get back whether the input is checked. Similarly, if you call <code>.text</code> on the input you&#39;ll get the text back, which is most often what you wanted to get.</p>\n<pre><code class=\"lang-js\">var a = require(&#39;dominus&#39;);\nvar b = jQuery;\n\na(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, value: &#39;Foo&#39; }).text();\n// &lt;- &#39;Foo&#39;\n\na(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, checked: true }).value();\n// &lt;- true\n\nb(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, value: &#39;Foo&#39; }).text();\n// &lt;- &#39;&#39;\n\nb(&#39;&lt;input&gt;&#39;).attr({ type: &#39;radio&#39;, checked: true }).val();\n// &lt;- &#39;Foo&#39;\n</code></pre>\n<p>One of the best aspects of Dominus, <em>besides its small size</em>, is the fact that it extends native JavaScript arrays <em>(using <a href=\"https://github.com/bevacqua/poser\"><code>poser</code></a>)</em>. That means you have access to all of the <code>Array</code> functional methods on any <code>Dominus</code> collections, such as <code>.forEach</code>, <code>.map</code>, <code>.filter</code>, <code>.sort</code> and so on.</p>\n<p>Taunus doesn&#39;t make any extensive DOM manipulation <em>(nor querying)</em> and doesn&#39;t need to use Dominus, but it may find a home in your application.</p>\n<p>You can check out the <em>complete API documentation</em> for <code>dominus</code> on <a href=\"https://github.com/bevacqua/dominus\">its GitHub repository</a>.</p>\n<h1 id=\"using-xhr-to-make-ajax-requests\">Using <code>xhr</code> to make AJAX requests</h1>\n<h1 id=\"using-measly-as-an-upgrade-to-xhr-\">Using <code>measly</code> as an upgrade to <code>xhr</code></h1>\n<h1 id=\"complementing-your-code-with-small-modules\">Complementing your code with small modules</h1>\n");
jade_debug.shift();
jade_debug.shift();
buf.push("</section>");
jade_debug.shift();
jade_debug.shift();}.call(this,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
} catch (err) {
  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, "section.ly-section.md-markdown\n  :markdown\n    # Complementary Modules\n\n    Taunus is a small library by MVC framework standards, sitting **below 15kB minified and gzipped**. It is designed to be small. It is also designed to do one thing well, and that's _being a shared-rendering MVC engine_.\n\n    Taunus can be used for routing, putting together controllers, models and views to handle human interaction. If you [head over to the API documentation][1], you'll notice that the server-side API, the command-line interface, and the `.taunusrc` manifest are only concerned with providing a conventional shared-rendering MVC engine.\n\n    In the server-side you might need to do other things besides routing and rendering views, and other modules can take care of that. However, you're used to having database access, search, logging, and a variety of services handled by separate libraries, instead of a single behemoth that tries to do everything.\n\n    > In the client-side, you might be used to your MVC framework of choice resolving everything on your behalf, from DOM manipulation and data-binding to hooking up with a REST API, and everywhere in between.\n\n    Taunus attempts to bring the server-side mentality of _\"not doing everything is okay\"_ into the world of client-side web application development as well. To that end, Taunus recommends that you give a shot to libraries that also do **one thing well**.\n\n    In this brief article we'll recommend three different libraries that play well with Taunus, and you'll also learn how to search for modules that can give you access to other functionality you may be interested in.\n\n    # Using `dominus` for DOM querying\n\n    [Dominus][2] is an extra-small DOM querying library, currently clocking around **4kB minified and gzipped**, almost _ten times smaller_ than it's competition. Unlike jQuery and popular friends, Dominus doesn't provide AJAX features, layout math, `<form>` manipulation, promises, tens of event binding methods, a selector engine written in plain JavaScript, nor a myriad of utility functions. Instead, Dominus focuses solely on providing a rich DOM querying and manipulation API that gets rid of inconsistencies across browsers.\n\n    While the API isn't exactly compatible with jQuery, it is definitely familiar to the jQuery adept. Chaining, versatility, expressiveness, and raw power are all core concerns for Dominus. You'll find that Dominus has more consistently named methods, given that it was built with a concise API in mind.\n\n    There's a few differences in semantics, and I believe that's a good thing. For instance, if you do `.value` on a checkbox or radio button you'll get back whether the input is checked. Similarly, if you call `.text` on the input you'll get the text back, which is most often what you wanted to get.\n\n    ```js\n    var a = require('dominus');\n    var b = jQuery;\n\n    a('<input>').attr({ type: 'radio', value: 'Foo' }).text();\n    // <- 'Foo'\n\n    a('<input>').attr({ type: 'radio', checked: true }).value();\n    // <- true\n\n    b('<input>').attr({ type: 'radio', value: 'Foo' }).text();\n    // <- ''\n\n    b('<input>').attr({ type: 'radio', checked: true }).val();\n    // <- 'Foo'\n    ```\n\n    One of the best aspects of Dominus, _besides its small size_, is the fact that it extends native JavaScript arrays _(using [`poser`][5])_. That means you have access to all of the `Array` functional methods on any `Dominus` collections, such as `.forEach`, `.map`, `.filter`, `.sort` and so on.\n\n    Taunus doesn't make any extensive DOM manipulation _(nor querying)_ and doesn't need to use Dominus, but it may find a home in your application.\n\n    You can check out the _complete API documentation_ for `dominus` on [its GitHub repository][2].\n\n    # Using `xhr` to make AJAX requests\n\n\n\n    # Using `measly` as an upgrade to `xhr`\n\n    # Complementing your code with small modules\n\n    [1]: /api\n    [2]: https://github.com/bevacqua/dominus\n    [3]: https://github.com/bevacqua/measly\n    [4]: https://github.com/Raynos/xhr\n    [5]: https://github.com/bevacqua/poser\n");
}
}